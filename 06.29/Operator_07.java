package chap3_Operator;

public class Operator_07 {
	public static void main(String[] args) {
		//화씨를 섭씨로 변환하는 코드. 변환 공식이 'C = 5/9 x (F - 32)' 라 할 때?
		//반환 결과값은 소수점 셋째자리에서 반올림 해야한다. Math.round() 사용 금지.
		int fah = 100;
		float cel = (int)((5/9f * (fah - 32))*100+0.5)/100f;
		
		// 5/9로 하면 정수형이기에 0이 나오니까, 소수를 유도하기 위해 둘중 하나에 f를 붙여준다.
		// 
		
		System.out.println(fah);
		System.out.println(cel);
		
		
		
		
		int fah2 = 100;
		float cel2 = ((int)(((5/9f * (fah - 32))+0.005f)*100))/100f;
		
		System.out.println(fah2);
		System.out.println(cel2);
		
	}
}
/*
 * 위는 정석이고, 아래는 내가푼 해답이다.
 * 결과는 같지만 더 어수선 하고 복잡하다.
 * chatGPT에게 물어보았다. 어느 코드를 더 권고하냐고.
 * GPT는 위 코드가 더 적합하다 하였다.
 * 차이는 이렇다.
 * 정확한 반올림: 위는 0.5를 더해줌으로써 소수점 아래 자리수를 반올림한다.
 * 아래의 0.005f와 같은 방식은 정확한 반올림을 보장하지 못할 수 있다.
 * 
 * 부동소수점의 한계라고 볼 수 있다.
 * 부동소수점 연산의 한계는 컴퓨터에서 실수를 표현하는 부동소수점 형식의 한계를 의미합니다. 
 * 부동소수점은 소수점 위치를 이동시키며 수를 표현하는 방식이기 때문에 정확한 실수 표현이 어려울 수 있습니다.
컴퓨터에서 사용되는 부동소수점 형식은 유한한 비트로 실수를 표현하는데, 이로 인해 실수 값의 정확도에 제한이 생깁니다. 
예를 들어, 실수를 이진수로 변환하여 표현할 때, 일부 실수 값은 정확하게 표현되지 않고 근사값으로 표현되는 경우가 있습니다.
이로 인해 부동소수점 연산에서는 정확한 결과를 보장하기 어려운 상황이 발생할 수 있습니다. 
작은 부동소수점 값의 덧셈, 뺄셈, 곱셈, 나눗셈 등의 연산에서는 반올림 오차나 정밀도 손실이 발생할 수 있습니다.
따라서 부동소수점 연산을 수행할 때는 결과의 정확도에 주의를 기울여야 하며, 
특히 반올림이나 정확한 소수점 이하 자릿수 처리에 대한 고려가 필요합니다.*/
